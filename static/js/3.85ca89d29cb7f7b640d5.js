webpackJsonp([3,28],{1:function(e,t){"use strict";e.exports={mounted:function(){this.$nextTick(function(){var e=document.querySelectorAll("code");if(e.length>0)for(var t=0;t<e.length;t++)hljs.highlightBlock(e[t])})}}},2:function(e,t,o){var n,r;n=o(1);var s=o(3);r=n=n||{},"object"!=typeof n.default&&"function"!=typeof n.default||(r=n=n.default),"function"==typeof r&&(r=r.options),r.render=s.render,r.staticRenderFns=s.staticRenderFns,e.exports=n},3:function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div")},staticRenderFns:[]}},33:function(e,t,o){"use strict";function n(e){return e&&e.__esModule?e:{default:e}}var r=o(2),s=n(r);e.exports={extends:s.default}},73:function(e,t,o){var n,r;n=o(33);var s=o(92);r=n=n||{},"object"!=typeof n.default&&"function"!=typeof n.default||(r=n=n.default),"function"==typeof r&&(r=r.options),r.render=s.render,r.staticRenderFns=s.staticRenderFns,e.exports=n},92:function(e,t){e.exports={render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",{staticClass:"page article"},[o("h2",{staticClass:"title"},[e._v("《ES6标准入门》笔记之九：Symbol")]),e._v(" "),e._m(0),e._v(" "),o("footer",[e._v("2017年05月13日")]),e._v(" "),o("comments")],1)},staticRenderFns:[function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",{staticClass:"content"},[o("h3",{staticClass:"title"},[e._v("概述")]),e._v(" "),o("p",[e._v("ES5中对象属性名都是字符串，容易造成属性名的冲突。引入Symbol的目的就是解决这个问题。它是JavaScript语言的第七种类型（Undefined、NULL、Boolean、String、Number、Object）。")]),e._v(" "),o("p",[e._v("Symbol值通过Symbol函数生成，可以接受一个字符串作为参数，表示对Symbol实例的描述，使之在控制台显示或者转为字符串时好区分。")]),e._v(" "),o("pre",[o("code",[e._v("var s1 = Symbol('foo') // Symbol(foo)\nvar s2 = Symbol('bar') // Symbol(bar)")])]),e._v(" "),o("p",[o("strong",[e._v("Symbol值不能与其他类型的值进行运算，否则报错。")])]),e._v(" "),o("p",[e._v("Symbol值可以显示转为字符串或者布尔值，但是不能转为数值。")]),e._v(" "),o("pre",[o("code",[e._v('var sym = Symbol()\nBoolean(sym) // true\nsym.toString() // "Symbol()"')])]),e._v(" "),o("h3",{staticClass:"title"},[e._v("作为属性名的Symbol")]),e._v(" "),o("p",[e._v("由于每个Symbol值都是不相等的，因此Symbol值可以作为标识符用于对象的属性名，保证不会出现同名的属性。")]),e._v(" "),o("pre",[o("code",[e._v('var sym = Symbol()\nvar a = {}\na[sym] = "abc"\n\nvar b = { [sym]: "123" }')])]),e._v(" "),o("p",[o("strong",[e._v("Symbol值作为对象属性名时不能使用点运算符。")])]),e._v(" "),o("p",[e._v("Symbol类型可用于定义一组常量，可保证这组常量的值都是不相等的。")]),e._v(" "),o("pre",[o("code",[e._v("log.levels = {\n    DEBUG: Symbol('debug'),\n    INFO: Symbol('info'),\n    WARN: Symbol('warn')\n}")])]),e._v(" "),o("h3",{staticClass:"title"},[e._v("属性名的遍历")]),e._v(" "),o("p",[e._v("Symbol作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。有一个Object.getOwnPropertySymbols方法可以指定对象的所有Symbol属性。")]),e._v(" "),o("pre",[o("code",[e._v("var obj = { a: 111 }\nvar foo = Symbol('foo')\nvar bar = Symbol('bar')\nobj[foo] = '222'\nobj[bar] = '333'\nObject.getOwnPropertyNames(obj) // [\"a\"]\nObject.getOwnPropertySymbols(obj) // [Symbol(foo), Symbol(bar)]")])]),e._v(" "),o("p",[e._v("另外一个新的API："),o("strong",[e._v("Reflect.ownKeys")]),e._v("方法可以返回所有类型的键名（包括了Symbol键名）。")])])}]}}});