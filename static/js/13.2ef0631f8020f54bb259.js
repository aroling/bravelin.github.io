webpackJsonp([13,32],{1:function(r,e){"use strict";r.exports={mounted:function(){this.$nextTick(function(){var r=document.querySelectorAll("code");if(r.length>0)for(var e=0;e<r.length;e++)hljs.highlightBlock(r[e])})}}},2:function(r,e,t){var n,v;n=t(1);var a=t(3);v=n=n||{},"object"!=typeof n.default&&"function"!=typeof n.default||(v=n=n.default),"function"==typeof v&&(v=v.options),v.render=a.render,v.staticRenderFns=a.staticRenderFns,r.exports=n},3:function(r,e){r.exports={render:function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div")},staticRenderFns:[]}},27:function(r,e,t){"use strict";function n(r){return r&&r.__esModule?r:{default:r}}var v=t(2),a=n(v);r.exports={extends:a.default}},71:function(r,e,t){var n,v;n=t(27);var a=t(116);v=n=n||{},"object"!=typeof n.default&&"function"!=typeof n.default||(v=n=n.default),"function"==typeof v&&(v=v.options),v.render=a.render,v.staticRenderFns=a.staticRenderFns,r.exports=n},116:function(r,e){r.exports={render:function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div",{staticClass:"page article"},[t("h2",{staticClass:"title"},[r._v("《ES6标准入门》笔记之十一：二进制数组")]),r._v(" "),r._m(0),r._v(" "),t("footer",[r._v("2017年05月18日")]),r._v(" "),t("comments")],1)},staticRenderFns:[function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div",{staticClass:"content"},[t("p",[r._v("二进制数组是JS操作二进制数据的接口。其目的是方便浏览器（WebGL）与显卡之间进行大量的、实时的交换数据。类似C语言的数组，可以直接操作内存。包括以下3类对象：")]),r._v(" "),t("p",[t("strong",[r._v("ArrayBuffer对象")]),r._v("：代表内存中的一段二进制数据，可以通过“视图”进行操作。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray对象")]),r._v("：共包括9种类型的视图，包括Int8、Uint8、Uint8C、Int16、Uint16、Int32、Uint32、Float32、Float64，主要用于读写简单类型的二进制数据。")]),r._v(" "),t("p",[t("strong",[r._v("DataView对象")]),r._v("：自定义复合格式的视图。")]),r._v(" "),t("h3",{staticClass:"title"},[r._v("ArrayBuffer对象")]),r._v(" "),t("p",[r._v("代表存储二进制数据的一段内存，"),t("strong",[r._v("不能直接读写，只能通过视图进行读写。")]),r._v("同时也是一个构造函数，用于分配一段可以存放数据的连续区域：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(bytes) // bytes代表字节数，每个字节默认值为0")])]),r._v(" "),t("p",[r._v("使用DataView读取ArrayBuffer：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dataView = new DataView(buf)\ndataView.getUint8(0) // 无符号8位整数格式读取：0")])]),r._v(" "),t("p",[r._v("TypedArray视图是一组构造函数，代表不同的数据格式：")]),r._v(" "),t("pre",[t("code",[r._v("var buffer = new ArrayBuffer(12)\nvar x1 = new Int32Array(buffer) // 32位带符号整数\nx1[0] = 1\nvar x2 = new Uint8Array(buffer) // 8位无符号整数\nx2[0] = 2\nx1[0] // 2")])]),r._v(" "),t("p",[r._v("ArrayBuffer实例的byteLength属性，返回所分配的内存区域字节长度。如果要分配的内存区域很大，有可能分配失败，因此有必要检查是否分配成功：")]),r._v(" "),t("pre",[t("code",[r._v("if (buf.byteLength == n) {\n    // 分配成功\n} else {\n    // 分配失败\n}")])]),r._v(" "),t("p",[r._v("ArrayBuffer实例的slice()方法，可以将内存区域的一部分复制生成一个新的ArrayBuffer对象：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(8)\nvar newBuf = buf.slice(0, 3) // 复制前3个字节")])]),r._v(" "),t("p",[r._v("slice方法的第一个参数表示复制开始的字节序号（含该字节），第二个参数表示复制结束的字节序号（不含，默认到结尾）。")]),r._v(" "),t("p",[t("strong",[r._v("ArrayBuffer.isView()")]),r._v("，静态方法，判断参数是否为ArrayBuffer的视图实例：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar v = new Int32Array(buf)\nArrayBuffer.isView(v) // true")])]),r._v(" "),t("h3",{staticClass:"title"},[r._v("TypedArray视图")]),r._v(" "),t("p",[r._v("TypedArray视图一共包括9种类型，每一种视图都是一种构造函数：")]),r._v(" "),t("p",[t("strong",[r._v("1、Int8Array")]),r._v("：8位有符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("2、Uint8Array")]),r._v("：8位无符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("3、Uint8ClampedArray")]),r._v("：8位无符号整数，溢出处理不同；")]),r._v(" "),t("p",[t("strong",[r._v("4、Int16Array")]),r._v("：16位有符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("5、Uint16Array")]),r._v("：16位无符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("6、Int32Array")]),r._v("：32位有符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("7、Uint32Array")]),r._v("：32位无符号整数；")]),r._v(" "),t("p",[t("strong",[r._v("8、Float32Array")]),r._v("：32位浮点数；")]),r._v(" "),t("p",[t("strong",[r._v("9、Float64Array")]),r._v("：64位浮点数；")]),r._v(" "),t("p",[r._v("普通数组与TypedArray数组的区别：")]),r._v(" "),t("p",[t("strong",[r._v("1、TypedArray数组的所有成员都是同一种类型；")])]),r._v(" "),t("p",[t("strong",[r._v("2、TypedArray数组的成员是连续的，不会有空位；")])]),r._v(" "),t("p",[t("strong",[r._v("3、TypedArray数组成员的默认值是0.")])]),r._v(" "),t("p",[t("strong",[r._v("4、TypedArray数组只是一层视图，本身不储存数据。")])]),r._v(" "),t("p",[r._v("构造函数原型：TypedArray(buffer, byteOffset=0, length?)：第一个参数必须，指向底层ArrayBuffer对象；第二个可选，视图开始的字节序号，默认为0；第三个可选，视图包含的数据个数，默认到内存区域结尾。")]),r._v(" "),t("p",[r._v("注意，byteOffset必须与所要建立的数据类型一致，否则会报错：")]),r._v(" "),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar v = new Int16Array(buf, 1) // ERROR")])]),r._v(" "),t("p",[r._v("如果需要从任意字节开始解读ArrayBuffer对象，必须使用DataView视图。")]),r._v(" "),t("p",[t("strong",[r._v("TypedArray(length)")]),r._v("：视图还可以不通过ArrayBuffer，直接分配内存生成。")]),r._v(" "),t("pre",[t("code",[r._v("var f64a = new Float64Array(8) // 64字节")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray(typedArray)")]),r._v("：接收另外一个TypedArray实例作为参数构造生成，此时新数组会开辟新的内存区域储存数据，不会在原数组的内存区域之上建立视图。")]),r._v(" "),t("pre",[t("code",[r._v("var x = new Int8Array([1, 1])\nvar y = new Int8Array(x)")])]),r._v(" "),t("p",[r._v("如果想基于相同的内存区域构造不同的视图，可以这样写：")]),r._v(" "),t("pre",[t("code",[r._v("var x = new Int8Array([1, 1])\nvar y = new Int8Array(x.buffer)")])]),r._v(" "),t("p",[t("strong",[r._v("TypedArray(arrayLikeObj)")]),r._v("：构造函数的参数也可以是一个普通数组，直接生成TypedArray实例。此时会重新开辟内存区域。")])])}]}}});